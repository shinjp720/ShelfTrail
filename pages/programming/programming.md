---
title: プログラミング全般
layout: default
---

# プログラミング全般 <a id="top" data-name="TOP"></a>

- プログラミングにおける共通の知識まとめ

---

## 設計原則とデザインパターン <a id="design-principles-n-patterns" data-name="設計原則とデザインパターン"></a>

### 変化に強いソフトウェア
- 保守性が高いこと。
  - 修正箇所が局所化され、他の部分に影響を与えないこと。

- 再利用性が高いこと。
  - ソフトウェアが部品化され、それを再利用することができる。

- 拡張性が高いこと。
  - ソフトウェアを構成する要素同士を疎結合にすることで、ソフトウェアを様々な実装で拡張することができる。

---

### SOLIDの原則

#### 単一責任の原則(SRP)
1つのソフトウェア構成要素(サブシステムやモジュール、クラス、関数など)に、変更する理由が2つ以上あるようではいけない。

大前提としてコードの修正にはコストがかかる。

そのコードを修正することでどこに影響があるか調査しなければならない。

修正の影響で、動作に支障が出ないか確認しなければならない。

変更による影響を最小限に抑えるようにソフトウェアを設計する必要がある。

単一責任の原則を適用することにより、ソフトウェア構成要素が持つ単一の責務が変更された時のみ、それが変更されるようにすることで変更による影響を最小限に抑えることができる。

#### 解放／閉鎖の原則(OCP)
ソフトウェアの構成要素は拡張のために開かれていて、修正のために閉じられていなければならない。

ソフトウェアの構成要素に機能拡張が発生した場合、既存のコードには修正を加えずに(閉じている)新しくコードを追加するだけで対応できる(開いている)ようにするということ。

既存のコードはバグがあった場合のみ修正する。

#### リスコフの置換原則(LSP)
もし、SがTの派生型であれば、プログラム内でT型のオブジェクトが使われている箇所は全てS型のオブジェクトで置換可能にする。

多態性を利用して利用者に対するインターフェースを統一し置換可能にすることで、拡張性を上げることができる。

#### インターフェース分離の原則(ISP)
利用者にとって不要なインターフェースに依存させてはならない。

インターフェースとは、要素を利用する側に提供される仕様で、メソッドでいうとメソッド名、パラメータ、戻り値の型などのメソッドのシグネチャ部分のことをいう。

#### 依存性逆転の原則(DIP)
抽象(上位要素)は詳細(下位要素)に依存してはならない。

---

### GRASP(GeneralResponsibilityAssignmentSoftwarePrinciple)

#### 依存度を下げるための原則
- 疎結合
  - 結合度(他の要素との結び付きの強さ)が低くなるように責任を配置するという基本原則。
- 高凝集
  - 凝集度(構成要素に含まれる機能性のまとまり)が高くなるように責任を配置するという基本原則。
- 間接化
  - ２つのクラスの中間に要素を設け、両社の仲介を行う責務を割り当てることで２つのクラスの疎結合を促進するという原則。

#### 役割分担に関する原則
- 情報エキスパート
  - 責務を遂行するために必要な情報を全て保持しているクラスに対して責務を割り当てるべきという原則。情報エキスパートの原則を適用することにより、責務を遂行するために必要な情報を全て保持しているクラスに対して責務が集中するるので、ソフトウェアの凝集度が高くなる。
- 生成者
  - クラスを生成する責務はそのクラスを集約するクラスのように、そのクラスを直接使用し、そのクラスを初期化するために必要な情報を持っているクラスに割り当てるべきという原則。
  - 生成者の原則を適用することにより、クラス間の結合度が低くなり理解のしやすさ、カプセル化が促進され、オブジェクトの再利用性を高くすることができる。
- 純粋人工物
  - 疎結合や高凝集、それらから得られる再利用性が情報エキスパートで実現できない場合、それを実現するためのクラスを導入すべきだという原則。純粋人工物の原則を適用することにより、情報エキスパートの高凝集を確保するとともに、情報エキスパートに対する疎結合が促進され、その再利用性が高くなる。
- コントローラ
  - システム全体を表すクラスや、ユースケースシナリオを表現するユーザーインタフェースでないクラスに、システムイベントをコントロールする責務を割り当てるという原則。コントローラの原則を適用することにより、ユーザーインタフェースや他システムに対する結合度が下がり、ソフトウェアの再利用性を高くすることができる。

#### 変動をカプセル化するための原則
- 多態性
  - クラスの機能のうち変動する部分の仕様を下位クラスに継承させ、下位クラスで具体的なふるまい(実装)を定義することで、再利用性や拡張性を上げるという原則。多態性の原則を適用することにより、そのクラスを利用する側に対する結合度を下げ、クラスの再利用性や拡張性を上げることができる
- 変動からの保護
  - クラスの機能のうち変動する不安定な部分を別のクラスとして切り出して、それを合成することで、変動しない部分を保護するとともに、変動部分の拡張性を上げるという原則。変動からの保護の原則を適用して、変動部分を切り出すことで、それを高凝集にし、交換可能性を高くすることで変動部分の拡張性を上げることになる。

---

### コマンド・クエリ分離の原則(CQS)

#### プログラミングにおける副作用を最小限に抑えることで保守性と再利用性を確保するための設計原則。
- 式の評価による作用には、主たる作用とそれ以外の副作用とがある。
  - 式は、評価値を得ること(関数では「引数を受け取り値を返す」)が主たる作用とされ、それ以外のコンピューターの論理状態(ローカル環境以外の状態変数の値)を変化させる作用を副作用という。

  - 副作用は予期せぬエラーを発生させるリスクとなり、リスクを下げるために以下のようなコストを発生させ、結果的にソフトウェアの保守性を下げることになる。 副作用によってどこに影響があるか調査しなければならない。その影響によって動作に支障が出ないようにしなければならない。
  - また、副作用が起こるクラスなどのソフトウェアの構成要素は、常に同じ結果を提供するわけではないのでソフトウェアの再利用性を下げる

- 同じ条件を与えれば必ず同じ結果が得られる。
- 他のいかなる機能の結果にも影響を与えない。
  - というメソッドや関数の性質を**参照透過性**という。

- あるメソッドがスコープ外のオブジェクトの状態を変更するのなら、そのメソッドはコマンドであり、値を戻してはならない。
- あるメソッドが何らかの値を戻すのであれば、そのメソッドはクエリであり、オブジェクトの状態を変えてはならない。
- クラスの属性を参照する(変更を行わない)場合はクエリとして成立する。
  - 上記のようにコマンドとクエリを分離させることにより保守性の高いコードとなる。

- 単に引数を加工して結果を返すだけのロジックはできる限り副作用のないクエリとして実装し、実際に状態を変化させるコマンドを最小限に留めるようにする。

- 状態を変更するメソッドとしないメソッドを明確に分けることで様々な状況において自信をもって問い合わせを行うことができる。

- オブジェクトを分析するときは、オブジェクトが同一性を持ち同一のものが状態を変えるオブジェクトなのか？同一性をもつ必要のないオブジェクトなのか？をよく検討する必要がある。

- 同一性を持つ必要がないのであれば状態を更新するコマンドとして実装する必要がなく副作用を減らすことができる。

---

## 命名規則 <a id="nameing-convention" data-name="命名規則"></a>

### スネークケース (snake_case)
- 単語をアンダースコア (_) で区切る形式。
- 例: my_variable_name
- 主にPythonやSQLで使われる。

### キャメルケース (camelCase)
- 最初の単語を小文字で始め、以降の単語の先頭を大文字にする形式。
- 例: myVariableName
- 主にJavaScriptやJavaのローカル変数や関数で使われる。

### パスカルケース (PascalCase)
- 各単語の先頭を大文字にする形式。
- 例: MyVariableName
- 主にクラス名や型名で使われる（C#やJavaやPython）。

### ケバブケース (kebab-case)
- 単語をハイフン (-) で区切る形式。
- 例: my-variable-name
- 主にURLやHTMLやCSSクラス名で使われる。

### アッパースネークケース (UPPER_SNAKE_CASE)
- 全てを大文字にしてアンダースコアで区切る形式。
- 例: MY_VARIABLE_NAME
- 主に定数の命名に使われる（C言語やPython）。

### スクリーミングスネークケース (SCREAMING_SNAKE_CASE)
- アッパースネークケースの別名で、強調の意味も込められる。
- 例: ERROR_MESSAGE

### タイトルケース (Title Case)
- 各単語の最初を大文字にし、スペースで区切る形式。
- 例: My Variable Name
- 文書やデザイン要素のタイトルに使われる。

### ハンガリアン記法 (Hungarian Notation)
- 変数の型や用途をプレフィックスで示す形式。
- 例: strName (文字列), iCount (整数)
- レガシーシステムや古いコードで見られる。

### ドットケース (dot.case)
- 単語をドット (.) で区切る形式。
- 例: my.variable.name
- 一部の構成ファイル（JSONなど）やパッケージ名で使われる。

### トレインケース (Train-Case)
- ケバブケースの変種で、各単語の先頭を大文字にする。
- 例: My-Variable-Name
- デザインやドキュメントで見かけることがある。

---

## 英語形式の比較演算子 <a id="english-like" data-name="英語形式の比較演算子"></a>

| 演算子 | 説明 | C言語 |
| --- | --- | --- |
| eq | 等しい | x == y |
| ne | 等しくない | x != y |
| lt | より小さい | x < y |
| le | 以下 | x <= y |
| gt | より大きい | x > y |
| ge | 以上 | x >= y |

---

## 用語 <a id="term" data-name="用語"></a>

### 宣言
名前（識別子）とその型・属性をコンパイラに知らせること。定義を伴う場合と伴わない場合がある。

```c
extern int x;     // 宣言：xはどこかで定義される（ここでは定義していない）
int y;            // 宣言＋定義（ストレージ領域も割り当て）
int foo(int);     // 関数の宣言
```

### 定義（definition）
実体（ストレージ領域）や内容を与えること。つまり、値を保持できるようにすること。

```c
int x = 0;       // 定義：xという変数を定義し初期化
int foo() {      // 定義：fooという関数の本体
    return 1;
}
```

int x; も定義とみなされる（初期化してなくてもストレージが割り当てられる）。
extern int x; は「宣言」のみで「定義」ではない。

### 式（expression）
値を生成する構文。評価されると「値」または「副作用（変数への代入や関数呼び出しなど）」をもたらす。

```c
x + 1        // 式：x に 1 を足した結果の値を生成
a = 3        // 式：代入も式。代入の結果（値）は 3
foo(x)       // 関数呼び出しも式
```

### 文（statement）
何かの処理を行う命令的な構文。式の評価・制御構造・定義などが含まれる。

```c
a = b + 1;    // 式文（expression statement）
if (a > 0) {  // if文（制御文）
    printf("OK");
}
int x = 3;    // 宣言文（declaration statement）
```

Cでは文（statement）はセミコロンで終わる。関数の中で書けるのは基本的に文。

### 評価（evaluation）
式を処理して値や副作用を生じさせる行為。

```c
int a = 2;
int b = a + 3;  // 式 a + 3 を評価 → 5
```

### 値（value）
式を評価した結果のデータそのもの。整数・浮動小数点・アドレスなど。

---

